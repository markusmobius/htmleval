<!DOCTYPE html>
<html>
<head>
    <title>a test of annotated text</title>
    <style>
        details > summary {
            cursor: pointer;
            font-weight: bold;
        }
        .hidden-content {
            display: none;
        }
        details[open] .hidden-content {
             display: block;
        }
        select {
            /* Style adjustments for the dropdown */
            padding: 5px;
            margin: 0;
            border-radius: 5px;
        }
        input[type="checkbox"] {
            transform: scale(2); /* Adjust the scale value as needed */
            /* margin: 10px; Optional: Adjust the margin to align the checkbox */
        }
        .scrollable-box {
            max-height: 50vh;
            overflow-y: scroll;
            border: 1px solid #ccc;
            padding: 10px;
        }
        .scrollable-container-one {
            display: flex;
            justify-content: center;
        }
        .scrollable-box-one {
            width: 100%;
            height: 400px; /* Adjust the height as needed */
            overflow-y: auto;
            border: 1px solid #ccc;
            padding: 10px;
            box-sizing: border-box;
        }
        .scrollable-container-two {
            display: flex;
            justify-content: space-between;
        }
        .scrollable-box-two {
            width: 48%;
            height: 400px; /* Adjust the height as needed */
            overflow-y: auto;
            border: 1px solid #ccc;
            padding: 10px;
            box-sizing: border-box;
        }
        .annotated-text span {
            padding: 2px 4px;
            border-radius: 3px;
            cursor: pointer;
            position: relative;
        }
        .annotated-text span:hover::after {
            content: attr(data-details);
            position: absolute;
            left: 0;
            top: 100%;
            white-space: nowrap;
            background: #333;
            color: #fff;
            padding: 5px;
            border-radius: 3px;
            z-index: 10;
            font-size: 12px;
        }
    </style>
    <link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" rel="stylesheet"/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
</head>
<body>

    <div class="container mt-3">
        <dl class="row">
            <dt class="col-sm-2">Reviewer</dt>
            <dd class="col-sm-2">Sir Kiran Kiranelton</dd>          
            <dt class="col-sm-2">Evaluation</dt>
            <dd class="col-sm-2">a test of annotated text</dd>
            <dd class="col-sm-2">&nbsp;</dd>
            <dd class="col-sm-2" id="completedstatus">0% complete</dd>
        </dl>
    </div>

    <div class="container mt-3" id="tabs">

    </div>

    <script>
        // Inputs: 
// - Instructions: The instructions for the evaluation (a list of strings)
// - DataMatrix: The data we need to fill in. It should be organised in such a way that it fills.
// - StructureMatrix: This gives the "structure" of the evaluation. 

// Example:
// In this example we have two tabs. Each tabs contain a scrollbox. Then they contain "nested" content. This content has two tabs. The first tab contains a text block, a single question checkbox, and a table row unique select.
// The second tab contains a text block and a single question checkbox.

// overall_data = [
//     {   
//         "tab_id": "name1",
//         "content": [
//             {
//                 "type": "scrollbox",
//                 "header": {"text": "ScrollBox", "size": 2},
//                 "text": "this is a scrollbox \n and here is line 2"
//             },
//             {
//                 "type": "inner_tabs",
//                 "inner_tab_id": "name2",  
//                 "content": [
//                     {
//                         "inner_tab_id": "inner_tab11",
//                         "content":
//                         [

//                             {
//                                 "type": "text",
//                                 "header": {"text": "Text Title", "size": 2},
//                                 "text": "Here goes some text"
//                             },
//                             {
//                                 "type": "single-question-checkbox",
//                                 "varname": "favourite_colour",
//                                 "question": "What is your favourite colour?",
//                                 "options": [{"opt_name": "red", "text": "Red"}, {"opt_name": "blue", "text": "Blue"}, {"opt_name": "green", "text": "Green"}]
//                             },
//                             {
//                                 "type": "single-question-checkbox",
//                                 "varname": "favourite_animal",
//                                 "question": "What is your favourite animal?",
//                                 "options": [{"opt_name": "dog", "text": "Dog"}, {"opt_name": "cat", "text": "Cat"}, {"opt_name": "fish", "text": "Fish"}]
//                             },
//                             {
//                                 "type": "table_row_unique_select",
//                                 "col_names": ["Action", "Actor"],
//                                 "questions": [{"varname": "dog_name", "text": "What is your dogs name?"}, {"varname": "why_cat_dead", "text": "Why, if there is a god, is my cat dead?"}],
//                                 "options": [[{"opt_name": "rex", "text": "Rex"}, {"opt_name": "fido", "text": "Fido"}], [{"opt_name": "god_hates_cats", "text": "God hates cats"}, {"opt_name": "cat_hates_god", "text": "Cat hates god"}]], 
//                                 "rows": [{"text_columns": ["this is the action", "this is the actor"], "css": ["danger", "success"]}, {"text_columns": ["this is the action", "this is the actor"], "css": ["danger", "success"]}]
//                             }
//                         ]
//                     },
//                     {
//                         "inner_tab_id": "inner_tab12",
//                         "content":
//                         [
//                             {
//                                 "type": "text",
//                                 "header": {"text": "Text Title", "size": 2},
//                                 "text": "Here goes some text"
//                             },
//                             {
//                                 "type": "single-question-checkbox",
//                                 "varname": "favourite_colour",
//                                 "question": "What is your favourite colour?",
//                                 "options": [{"opt_name": "red", "text": "Red"}, {"opt_name": "turqoise", "text": "Turqoise"}, {"opt_name": "green", "text": "Green"}]
//                             }
//                         ]
//                     }
//                 ]
//             }
//         ]
//     },
//     {
//         "tab_id": "tab2",
//         "content": [
//             {
//                 "type": "scrollbox",
//                 "header": {"text": "ScrollBox", "size": 2},
//                 "text": "this is a scrollbox \n and here is line 2"
//             },
//             {
//                 "type": "inner_tabs",
//                 "inner_tab_id": "inner_tab2",
//                 "content": [
//                     {
//                         "inner_tab_id": "inner_tab21",
//                         "content":
//                         [

//                             {
//                                 "type": "text",
//                                 "header": {"text": "Text Title", "size": 2},
//                                 "text": "Here goes some text"
//                             },
//                             {
//                                 "type": "single-question-checkbox",
//                                 "varname": "favourite_colour",
//                                 "question": "What is your favourite colour?",
//                                 "options": [{"opt_name": "red", "text": "Red"}, {"opt_name": "blue", "text": "Blue"}, {"opt_name": "green", "text": "Green"}]
//                             },
//                             {
//                                 "type": "single-question-checkbox",
//                                 "varname": "favourite_animal",
//                                 "question": "What is your favourite animal?",
//                                 "options": [{"opt_name": "dog", "text": "Dog"}, {"opt_name": "cat", "text": "Cat"}, {"opt_name": "fish", "text": "Fish"}]
//                             },
//                             {
//                                 "type": "table_row_unique_select",
//                                 "col_names": ["Action", "Actor"],
//                                 "questions": [{"varname": "dog_name", "text": "What is your dogs name?"}, {"varname": "why_cat_dead", "text": "Why, if there is a god, is my cat dead?"}],
//                                 "options": [[{"opt_name": "rex", "text": "Rex"}, {"opt_name": "fido", "text": "Fido"}], [{"opt_name": "god_hates_cats", "text": "God hates cats"}, {"opt_name": "cat_hates_god", "text": "Cat hates god"}]], 
//                                 "rows": [{"text_columns": ["this is the action", "this is the actor"], "css": ["danger", "success"]}, {"text_columns": ["this is the action", "this is the actor"], "css": ["danger", "success"]}]
//                             }
//                         ]
//                     }
//                 ]
//             }
//         ]
//     }
// ] 

overall_data = [{"tab_id": "Tab 1", "nav_tab_name": "Tab 1 Name", "header": {"text": "Tab 1 Header", "size": 1}, "content": [{"type": "annotated_text", "paragraphs": [{"fragments": [{"text": "This is an example text with two fragments.", "id": "fragment1"}, {"text": "Together they make up one paragraph.", "id": "fragment2"}]}, {"fragments": [{"text": "This is a second paragraph.", "id": "fragment3"}]}]}, {"type": "message_display", "content_map": {"fragment1": [{"type": "text", "header": {"text": "Highlight 1 Title", "size": 2}, "text": "This is the content for highlight 1."}, {"type": "single-question-checkbox", "varname": "question1", "question": "What is your favorite color?", "options": [{"opt_name": "red", "text": "Red"}, {"opt_name": "blue", "text": "Blue"}, {"opt_name": "green", "text": "Green"}]}], "fragment2": [{"type": "text", "header": {"text": "Highlight 2 Title", "size": 2}, "text": "This is the content for highlight 2."}, {"type": "single-question-checkbox", "varname": "question2", "question": "What is your favorite animal?", "options": [{"opt_name": "dog", "text": "Dog"}, {"opt_name": "cat", "text": "Cat"}, {"opt_name": "fish", "text": "Fish"}]}], "fragment3": [{"type": "text", "header": {"text": "Highlight 3 Title", "size": 2}, "text": "This is the content for highlight 3."}]}}]}]


fullData = null;

// New Full Data, actually probably should have one per "series" of checkboxes, because we only want one answer per question.
// This is a list of dictionaries. Each dictionary has a compoundID and a value. The compoundID is a dictionary with the outer, inner, varname, and opt_name.
// The value is the value of the checkbox.
// fullData = [{"compoundID": {"outer": "tab1", "inner": "inner_tab11", "varname": "favourite_colour"}, "value": "red"},
//     {"compoundID": {"outer": "tab1", "inner": "inner_tab11", "varname": "favourite_animal"}, "value": "dog"},
//     {"compoundID": {"outer": "tab1", "inner": "inner_tab11", "row": 1, "varname": "dog_name"}, "value": "rex"},
//     {"compoundID": {"outer": "tab1", "inner": "inner_tab11", "row": 1, "varname": "why_cat_dead"}, "value": "god_hates_cats"},
//     {"compoundID": {"outer": "tab1", "inner": "inner_tab12", "varname": "favourite_colour"}, "value": "turqoise"},
//     {"compoundID": {"outer": "tab2", "inner": "inner_tab21", "varname": "favourite_colour"}, "value": "red"},
//     {"compoundID": {"outer": "tab2", "inner": "inner_tab21", "varname": "favourite_animal"}, "value": "dog"},
//     {"compoundID": {"outer": "tab2", "inner": "inner_tab21", "row": 0, "varname": "dog_name"}, "value": "rex"},
//     {"compoundID": {"outer": "tab2", "inner": "inner_tab21", "row": 0, "varname": "why_cat_dead"}, "value": "god_hates_cats"},
//     {"compoundID": {"outer": "tab2", "inner": "inner_tab21", "row": 1, "varname": "dog_name"}, "value": "rex"},
//     {"compoundID": {"outer": "tab2", "inner": "inner_tab21", "row": 1, "varname": "why_cat_dead"}, "value": "god_hates_cats"}]


// Let's start by building the building blocks we need. 

var buildText = function(text_dict) {
    // This function builds a text block. It returns a list of things to append to the pane in order. 
    var to_append_to_pane = [];
    if (text_dict["header"] !== null) {
        var header = document.createElement("h" + text_dict["header"]["size"]);
        header.innerHTML = text_dict["header"]["text"];
        to_append_to_pane.push(header);
    }
    var text = document.createElement("p");
    text.innerHTML = text_dict["text"];
    to_append_to_pane.push(text); 
    return to_append_to_pane;
}

var buildScrollbox = function(scrollbox_dict) {
    // This function builds a scrollbox. It returns a list of things to append to the pane in order. 
    var to_append_to_pane = [];
    if (scrollbox_dict["header"] !== null) {
        var header = document.createElement("h" + scrollbox_dict["header"]["size"]);
        header.innerHTML = scrollbox_dict["header"]["text"];
        to_append_to_pane.push(header);
    }
    var scrollableContainer = document.createElement("div");
    scrollableContainer.className = "scrollable-container-one";

    var inner_div = document.createElement("div");
    inner_div.className = "scrollable-box-one";
    
    var text = scrollbox_dict['text'].split('\n');
    
    for (var j = 0; j < text.length; j++) {
        var pnws = text[j].trim();
        if (pnws != "") {
            var p = document.createElement("p");
            p.innerHTML = pnws;
            inner_div.appendChild(p);
        }
    }

    scrollableContainer.appendChild(inner_div);
    to_append_to_pane.push(scrollableContainer);

    return to_append_to_pane;
}

var buildSingleQuestionCheckbox = function(single_question_checkbox_dict, compoundID) {
    var to_append_to_pane = [];
    
    var container = document.createElement("div");
    container.className = "mb-3 row"; // Use mb-3 for margin bottom and row for flexbox
    // Need to create a flag that we can then do a querySelector on to find this "parent" div.
    container.id = 'single-question-checkbox';

    var question = document.createElement("label");
    question.className = "col-sm-6 col-form-label"; 
    question.innerHTML = single_question_checkbox_dict["question"];
    container.appendChild(question);

    var optionsContainer = document.createElement("div");
    optionsContainer.className = "col-sm-6 col-form-label"; // Use flexbox for inline checkboxes and center alignment

    var options = single_question_checkbox_dict["options"];
    var varname = single_question_checkbox_dict["varname"];
    
    for (var i = 0; i < options.length; i++) {
        var option = document.createElement("div");
        option.className = "form-check form-check-inline"; // Inline checkboxes
        var input = document.createElement("input");
        input.type = "checkbox";
        input.className = "form-check-input";
        input.id = `${compoundID.outer}|${compoundID.inner}|${varname}|${options[i].opt_name}`; // Ensure unique ID
        
        console.log(compoundID.outer, compoundID.inner, varname, options[i].opt_name);
        // Initialize checkbox value from fullData
        var fullDataEntry = fullData.find(entry => 
            entry.compoundID.outer === compoundID.outer &&
            entry.compoundID.inner === compoundID.inner &&
            entry.compoundID.varname === varname
        );
        if (fullDataEntry && fullDataEntry.value === options[i].opt_name) {
            input.checked = true;
        }

        var label = document.createElement("label");
        label.className = "form-check-label";
        // var span = document.createElement("span");
        label.innerHTML = options[i].text;
        // label.appendChild(span);
        label.For = input.id; // Match the label's htmlFor with the input's id
        option.appendChild(input);
        option.appendChild(label);
        optionsContainer.appendChild(option);
    }
    container.appendChild(optionsContainer);
    to_append_to_pane.push(container);
    return to_append_to_pane;
}

var buildTableRowUniqueSelect = function(table_row_unique_select_dict, compoundID) {
    // This function builds a table row unique select. It returns a list of things to append to the pane in order. 
    // Here we create a table, each row has an entry for each text column, then it has a dropdown for each question. This dropdown is populated with the options. 
    // Each dropdown is, moreover, given a unique ID which is the compoundID + the varname of the question.
    var to_append_to_pane = [];
    var questions = table_row_unique_select_dict["questions"];
    var options = table_row_unique_select_dict["options"];
    var rows = table_row_unique_select_dict["rows"];
    var header = table_row_unique_select_dict["header"];
    
    var header_banner = document.createElement("h" + header["size"]);
    header_banner.innerHTML = header["text"];
    to_append_to_pane.push(header_banner);

    var tbl = document.createElement("table");
    tbl.className = "table table-striped table-hover";
    tbl.setAttribute("border", 1);

    var thead = document.createElement("thead");
    // Create the header row, needs column names for text columns, then also each question text as a header.
    var header_row = document.createElement("tr");
    var col_names = table_row_unique_select_dict["col_names"];
    for (var i = 0; i < col_names.length; i++) {
        var th = document.createElement("th");
        th.innerHTML = col_names[i];
        header_row.appendChild(th);
    }
    for (var i = 0; i < questions.length; i++) {
        var th = document.createElement("th");
        th.innerHTML = questions[i]["text"];
        header_row.appendChild(th);
    }
    thead.appendChild(header_row);
    tbl.appendChild(thead);

    var tbody = document.createElement("tbody");
    for (var i = 0; i < rows.length; i++) {
        var row = document.createElement("tr");
        var text_columns = rows[i]["text_columns"];
        for (var j = 0; j < text_columns.length; j++) {
            var td = document.createElement("td");
            td.innerHTML = text_columns[j];
            row.appendChild(td);
        }
        for (var j = 0; j < questions.length; j++) {
            var td = document.createElement("td");
            var select = document.createElement("select");
            select.className = "form-control";
            select.id = `${compoundID.outer}|${compoundID.inner}|${i}|${questions[j].varname}`;
            
            // Add default "Select" option
            var defaultOption = document.createElement("option");
            defaultOption.value = ""; // Corresponds to value=""
            defaultOption.innerHTML = "Select";
            select.appendChild(defaultOption);

            var options = table_row_unique_select_dict["options"][j];
            for (var k = 0; k < options.length; k++) {
                var option = document.createElement("option");
                option.value = options[k]["opt_name"];
                option.innerHTML = options[k]["text"];
                select.appendChild(option);
            }

            // Initialize select value from fullData
            console.log(`Checking fullData for ${compoundID.outer}, ${compoundID.inner}, ${i}, ${questions[j].varname}`);
            var fullDataEntry = fullData.find(entry => 
                entry.compoundID.outer === compoundID.outer &&
                entry.compoundID.inner === compoundID.inner &&
                entry.compoundID.row === i.toString() &&
                entry.compoundID.varname === questions[j].varname
            );
            console.log(fullDataEntry);
            if (fullDataEntry) {
                console.log(`Setting select value to ${fullDataEntry.value}`);
                select.value = fullDataEntry.value;
                // Need to find the dictionary in options where the opt_name is the same as the value of the fullDataEntry
                var opt = options.find(option => option.opt_name === fullDataEntry.value);
                // now set the td containing our value to have the css class of the opt_name if it exists and the css exists. It will only give "success or danger" so needs to be mapped. 
                if (opt && opt.css) {
                    td.className = "table-" + opt.css; 
                }
            }

            td.appendChild(select);
            row.appendChild(td);
        }
        tbody.appendChild(row);
    }
    tbl.appendChild(tbody);
    to_append_to_pane.push(tbl);
    return to_append_to_pane;
}

var buildAnnotatedText = function(annotated_text_dict) {
    var to_append_to_pane = [];
    var paragraphs = annotated_text_dict["paragraphs"];

    var container = document.createElement("div");
    container.className = "annotated-text";

    // Create the interactive-text element
    var interactiveText = document.createElement('interactive-text');
    interactiveText.setAttribute('data', JSON.stringify({
        paragraphs: paragraphs.map(paragraph => ({
            fragments: paragraph.fragments.map(fragment => ({
                id: fragment.id,
                text: fragment.text,
                state: 'marked' // Assuming all fragments are marked
            }))
        }))
    }));

    container.appendChild(interactiveText);
    to_append_to_pane.push(container);

    return to_append_to_pane;
}
var buildMessageDisplay = function(message_display_dict) {
    var to_append_to_pane = [];
    var message_map = message_display_dict["content_map"];

    // Create the message-display element
    var messageDisplay = document.createElement('message-display');
    messageDisplay.setAttribute('content-map', JSON.stringify(message_map));

    to_append_to_pane.push(messageDisplay);

    return to_append_to_pane;
}

var buildBlock = function(block, compoundID) {
    if (block["type"] == "text") {
        console.log("text");
        return buildText(block);
    } else if (block["type"] == "scrollbox") {
        console.log("scrollbox");
        return buildScrollbox(block);
    } else if (block["type"] == "single-question-checkbox") {
        console.log("single-question-checkbox");
        return buildSingleQuestionCheckbox(block, compoundID);
    } else if (block["type"] == "table_row_unique_select") {
        console.log("table_row_unique_select");
        return buildTableRowUniqueSelect(block, compoundID);
    } else if (block["type"] == "inner_tabs") {
        console.log("inner_tabs");
        return buildTabs(block["content"], false, compoundID);
    } else if (block["type"] == "annotated_text") {
        console.log("annotated_text");
        return buildAnnotatedText(block);
    } else if (block["type"] == "message_display") {
        console.log("message_display");
        return buildMessageDisplay(block);
    }
}

var buildContent = function(content, compoundID) {
    // This function reads the json for a "content" and then calls the appropriate function to build it. 
    var to_append_to_pane = [];
    for (var i = 0; i < content.length; i++) {
        var block = content[i];
        var newCompoundID = { ...compoundID, inner: block.inner_tab_id || compoundID.inner };
        var to_append = buildBlock(block, newCompoundID);
        to_append_to_pane = to_append_to_pane.concat(to_append);
    }
    return to_append_to_pane;
}

function updateFullData(element) {
    const idParts = element.id.split('|');
    if (element.type === "checkbox") {
        var outer = idParts[0];
        var inner = idParts[1];
        var varname = idParts[2];
        var opt_name = idParts[3];
        var compoundID = { outer, inner, varname, opt_name };
    } else if (element.tagName === "SELECT") {
        var outer = idParts[0];
        var inner = idParts[1];
        var row = idParts[2];
        var varname = idParts[3];
        var compoundID = { outer, inner, row, varname };
    }

    if (element.type === "checkbox") {
        // Uncheck other checkboxes for the same question using the parent element
        const parent = element.closest('div#single-question-checkbox');
        const checkboxes = parent.querySelectorAll(`input[type="checkbox"][id^="${outer}|${inner}|${varname}"]`);
        checkboxes.forEach(checkbox => {
            if (checkbox !== element) {
                checkbox.checked = false;
            }
        });
    }

    // Update fullData
    const fullDataEntry = fullData.find(entry => JSON.stringify(entry.compoundID) === JSON.stringify(compoundID));
    if (fullDataEntry) {
        fullDataEntry.value = element.type === "checkbox" ? (element.checked ? opt_name : "") : element.value;
    } else {
        const newEntry = { compoundID, value: element.type === "checkbox" ? (element.checked ? opt_name : "") : element.value };
        fullData.push(newEntry);
    }

    console.log(`Updated fullData: ${JSON.stringify(compoundID)} = ${element.type === "checkbox" ? (element.checked ? opt_name : "") : element.value}`);
    console.log(fullData);
}

function checkTabCompletion(tabId) {
    const tabPane = document.getElementById(tabId);
    if (!tabPane) return; // Exit if tabPane is not found

    // Check nested tabs first
    const nestedTabs = tabPane.querySelectorAll('.tab-pane');
    nestedTabs.forEach(nestedTab => {
        console.log(`Checking nested tab ${nestedTab.id}`);
        checkTabCompletion(nestedTab.id);
    });

    var allFilled = true;
    // Start by checking checkbox groups
    const checkbox_groups = tabPane.querySelectorAll(`div#single-question-checkbox`);
    checkbox_groups.forEach(checkbox_group => {
        const checkboxes = checkbox_group.querySelectorAll('input[type="checkbox"]');
        let anyChecked = false;
        checkboxes.forEach(checkbox => {
            if (checkbox.checked) {
                anyChecked = true;
            }
        });
        if (!anyChecked) {
            allFilled = false;
            console.log(`Checkbox group ${checkbox_group.id} is not complete`);
        }
    });

    // Check select dropdowns
    const inputs = tabPane.querySelectorAll('select');
    inputs.forEach(input => {
        if (input.tagName === 'SELECT' && (input.value === '' || input.value === 'Select')) {
            allFilled = false;
        }
    });

    // Check if all nested tabs are complete
    const nestedTabButtons = tabPane.querySelectorAll('.nav-link');
    let allNestedTabsComplete = true;
    nestedTabButtons.forEach(button => {
        if (!button.classList.contains('bg-success-subtle')) {
            allNestedTabsComplete = false;
            console.log(`Tab ${button.innerHTML} is not complete`);
        }
    });

    const tabButton = document.querySelector(`button[aria-controls="${tabId}"]`);
    if (allFilled && allNestedTabsComplete) {
        tabButton.classList.add('bg-success-subtle');
        console.log(`Tab ${tabId} is complete`);
    } else {
        tabButton.classList.remove('bg-success-subtle');
        console.log(`Tab ${tabId} is not complete`);
    }
}

function addInputEventListeners() {
    const inputs = document.querySelectorAll('input[type="checkbox"], select');
    inputs.forEach(input => {
        input.addEventListener('change', () => {
            updateFullData(input);
            const tabPane = input.closest('.tab-pane');
            if (tabPane) {
                const outermostTabPane = tabPane.closest('.tab-content').closest('.tab-pane');
                const outermostTabId = outermostTabPane ? outermostTabPane.id : tabPane.id;
                checkTabCompletion(outermostTabId);
            }
            saveSurvey(); // Save survey data whenever a change is made

            // If we're dealing with select, we'll want to update the background of the td.
            // Need to use the id to find in overall_data the css class. Recall that the id is outer|inner|row|varname. 
            // Index of varname will give what options list we should be looking at. Then use the value to find the css class.
            

            if (input.tagName === "SELECT") {
                const idParts = input.id.split('|');
                const outer = idParts[0];
                const inner = idParts[1];
                const row = idParts[2];
                const varname = idParts[3];
            
                let block = overall_data.find(block => block.tab_id === outer);
                if (!block) {
                    console.error(`No block found with tab_id: ${outer}`);
                    return;
                }
            
                let innerBlock = block.content.find(block => block.inner_tab_id === inner);
                if (!innerBlock) {
                    // If not found directly, search recursively in nested inner_tabs
                    const findInnerBlock = (content) => {
                        for (let item of content) {
                            if (item.type === "inner_tabs") {
                                let found = item.content.find(innerItem => innerItem.inner_tab_id === inner);
                                if (found) return found;
                                found = findInnerBlock(item.content);
                                if (found) return found;
                            }
                        }
                        return null;
                    };
                    innerBlock = findInnerBlock(block.content);
                    if (!innerBlock) {
                        console.error(`No inner block found with inner_tab_id: ${inner} in tab_id: ${outer}`);
                        return;
                    }
                }
            
                let finalBlock = innerBlock.content.find(block => block.varname === varname);
                if (!finalBlock) {
                    // go through items in innerBlock one by one. Each time, try to identify "question", if no question, continue. 
                    // Then when you find question, (this is a list of dictionaries) look for the one with the varname.
                    // Keep number, go back one step and find the options list with that number.
                    // Then find the css class.
                    

                    // Step 1 enumerate
                    for (var i = 0; i < innerBlock.content.length; i++) {
                        var finalestblock = innerBlock.content[i];
                        if (finalestblock.type === "table_row_unique_select") {
                            for (var j = 0; j < finalestblock.questions.length; j++) {
                                if (finalestblock.questions[j].varname === varname) {
                                    var options = finalestblock.options[j];
                                    var opt = options.find(option => option.opt_name === input.value);
                                    if (opt && opt.css) {
                                        input.closest('td').className = "table-" + opt.css;
                                    }
                                    else {
                                        input.closest('td').className = "";
                                    }
                                }
                            }
                        }
                    }
                    
                }
            }
        });
    });
}

var initializeFullData = function(overall_data) {
    var fullData = [];
    var traverseContent = function(content, compoundID) {
        for (var i = 0; i < content.length; i++) {
            var block = content[i];
            var newCompoundID = { ...compoundID, inner: block.inner_tab_id || compoundID.inner };
            if (block.type === "single-question-checkbox") {
                fullData.push({ compoundID: { ...newCompoundID, varname: block.varname }, value: "" });
            } else if (block.type === "table_row_unique_select") {
                for (var j = 0; j < block.questions.length; j++) {
                    for (var k = 0; k < block.rows.length; k++) {
                        fullData.push({ compoundID: { ...newCompoundID, row: k, varname: block.questions[j].varname }, value: "" });
                    }
                }
            } else if (block.type === "inner_tabs") {
                traverseContent(block.content, newCompoundID);
            }
        }
    };

    for (var i = 0; i < overall_data.length; i++) {
        var compoundID = { outer: overall_data[i].tab_id, inner: "" };
        traverseContent(overall_data[i].content, compoundID);
    }

    return fullData;
};

// Update build function to call addInputEventListeners
var build = function(overall_data) {
    if (!fullData || fullData.length === 0) {
        fullData = initializeFullData(overall_data);
    }
    // This function attaches the whole to the root
    var root = document.getElementById("tabs");
    root.innerHTML = ""; // Clear previous content
    var content = buildTabs(overall_data, true);
    for (var i = 0; i < content.length; i++) {
        root.appendChild(content[i]);
    }
    addInputEventListeners();
    // Initial check for tab completion
    const tabPanes = document.querySelectorAll('.tab-pane');
    tabPanes.forEach(tabPane => {
        const outermostTabPane = tabPane.closest('.tab-content').closest('.tab-pane');
        const outermostTabId = outermostTabPane ? outermostTabPane.id : tabPane.id;
        checkTabCompletion(outermostTabId);
    });
    saveSurvey();
}

// Update buildTabs function to pass compoundID
var buildTabs = function(tabs, first = false, compoundID = { outer: "", inner: "" }) {
    // This function builds the tabs. It returns a list of things to append to the root in order.
    var to_append_to_root = [];
    // Add tabs_nav_bar
    var ul = document.createElement("ul");
    ul.className = "nav nav-tabs";
    ul.setAttribute("role", "tablist");

    // Add buttons for each tab. 
    for (var i = 0; i < tabs.length; i++) {
        (function(i) {
            var li = document.createElement("li");
            ul.appendChild(li);
            li.className = "nav-item";
            li.setAttribute("role", "presentation");
            var button = document.createElement("button");
            li.appendChild(button);
            let tabId; // Use let to create a block-scoped variable
            if (first == true) {
                tabId = tabs[i]['tab_id'];
            } else {
                tabId = tabs[i]['inner_tab_id'];
            }
            button.setAttribute("data-bs-toggle", "tab");
            button.setAttribute("id", tabId + "-tab");
            button.setAttribute("tabid", i);
            button.setAttribute("data-bs-target", "#" + tabId);
            button.setAttribute("type", "button");
            button.setAttribute("role", "tab");
            button.setAttribute("aria-controls", tabId);
            button.className = "nav-link";
            button.innerHTML = tabs[i].header ? tabs[i].header.text : (i); // Set to appropriate name

            // Add event listener to open the first inner tab when an outermost tab is clicked
            button.addEventListener('click', function() {
                console.log(`Opening first inner tab for ${tabId}`);
                const innerTabPane = document.querySelector(`#${tabId} .tab-content`);
                console.log(innerTabPane);
                if (innerTabPane) {
                    const activeInnerTab = innerTabPane.querySelector('.tab-pane.active');
                    if (!activeInnerTab) {
                        const firstInnerTabButton = document.querySelector(`#${tabId} .nav-tabs .nav-link`);
                        if (firstInnerTabButton) {
                            firstInnerTabButton.click();
                        }
                    }
                }
            });
        })(i);
    }

    to_append_to_root.push(ul);

    var tabcontent = document.createElement("div");
    tabcontent.className = "tab-content bg-light";

    for (var i = 0; i < tabs.length; i++) {
        var pane = document.createElement("div");
        tabcontent.appendChild(pane);
        if (first == true) {
            tabId = tabs[i]['tab_id'];
            newCompoundID = { outer: tabId, inner: "" };
        } else {
            tabId = tabs[i]['inner_tab_id'];
            newCompoundID = { outer: compoundID.outer, inner: tabId };
        }
        pane.className = "tab-pane";
        pane.setAttribute("id", tabId);
        pane.setAttribute("role", "tabpanel");
        pane.setAttribute("aria-labelledby", tabId + "-tab");
        pane.innerHTML = "";
        var content = buildContent(tabs[i]["content"], newCompoundID);
        for (var j = 0; j < content.length; j++) {
            pane.appendChild(content[j]);
        }
    }
    to_append_to_root.push(tabcontent);

    return to_append_to_root;
}





    </script>

    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.8/dist/umd/popper.min.js" integrity="sha384-I7E8VVD/ismYTF4hNIPjVp/Zjvgyol6VFvRkX/vR+Vc4jQkC+hVqc2pM8ODewa9r" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.min.js" integrity="sha384-0pUGZvbkm6XF6gxjEnlmuGrJXVbNuzT9qBBavbLwCsOGabYfZo0T0to5eqruptLy" crossorigin="anonymous"></script>

    <script>
        //surveyID
var reviewerID = "7f764c8b-09ed-49cf-9344-1ce2b6b34d06";
var saveSurvey = function() {
            //we assume that the data is stored in tabData
            fetch("https://www.kv.econlabs.org//" + reviewerID, {
                method: 'PUT',
                headers: {
                    'Content-type': 'text'
                },
                body: JSON.stringify(fullData)
            }).then((data) => {
                console.log("data saved");
            }).catch((error) => {
                console.log(error)
            });
};


var loadSurvey = async function() {
    try {
        var response = await fetch("https://www.kv.econlabs.org/" + reviewerID);
    } catch (e) {
        console.log("network is down");
        document.getElementById("completedstatus").innerHTML = "SERVER UNAVAILABLE";
        return;
    }
    if (!response.ok) {
        console.log("no stored data");
        fullData = initializeFullData(overall_data);
        build(overall_data);
    } else {
        var text = await response.text();
        fullData = JSON.parse(text);
        console.log("stored data retrieved: ", fullData);
        build(overall_data);
    }
};


(async() => {
    await loadSurvey(); 
})();

document.addEventListener("DOMContentLoaded", function() {
    loadSurvey().then(() => {
        // Automatically open the first tab and the first inner tab
        const firstTabButton = document.querySelector('.nav-tabs .nav-link');
        if (firstTabButton) {
            firstTabButton.click();
            const firstInnerTabButton = document.querySelector(`#${firstTabButton.getAttribute('aria-controls')} .nav-tabs .nav-link`);
            if (firstInnerTabButton) {
                firstInnerTabButton.click();
            }
        }
    });
});

    </script>
    
    <script>
        class InteractiveText extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({ mode: 'open' });
    }

    connectedCallback() {
        try {
            const data = JSON.parse(this.getAttribute('data'));
            this.render(data);
            console.log('InteractiveText connected with data:', data);
        } catch (error) {
            console.error('Failed to parse data attribute:', error);
        }
    }

    render(data) {
        const style = `
            <style>
                .fragment {
                    cursor: pointer;
                }
                .marked {
                    background-color: yellow;
                }
                .highlighted {
                    background-color: orange;
                }
            </style>
        `;

        const content = data.paragraphs.map(paragraph => {
            return `<p>${paragraph.fragments.map(fragment => {
                const className = fragment.state === 'marked' ? 'fragment marked' : 'fragment';
                return `<span class="${className}" data-id="${fragment.id}">${fragment.text}</span>`;
            }).join('')}</p>`;
        }).join('');

        this.shadowRoot.innerHTML = `${style}${content}`;
        this.addEventListeners();
    }

    addEventListeners() {
        this.shadowRoot.querySelectorAll('.fragment').forEach(fragment => {
            fragment.addEventListener('click', (event) => {
                const target = event.target;
                if (target.classList.contains('marked')) {
                    // Remove 'highlighted' class from all other fragments
                    this.shadowRoot.querySelectorAll('.highlighted').forEach(highlightedFragment => {
                        highlightedFragment.classList.remove('highlighted');
                    });

                    // Toggle 'highlighted' class on the clicked fragment
                    target.classList.toggle('highlighted');

                    const eventDetail = target.getAttribute('data-id');
                    const customEvent = new CustomEvent('interactivetext', { detail: eventDetail });
                    document.dispatchEvent(customEvent);
                    console.log(`Event 'interactivetext' transmitted with ID: ${eventDetail}`);
                }
            });
        });
    }
}

customElements.define('interactive-text', InteractiveText);
    </script>

    <script>
        class MessageDisplay extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({ mode: 'open' });
    }

    connectedCallback() {
        this.render();
        this.updateContentMap();
        document.addEventListener('interactivetext', this.handleEvent.bind(this));
        console.log('MessageDisplay connected');
        console.log('Initial content-map:', this.getAttribute('content-map'));
    }

    disconnectedCallback() {
        document.removeEventListener('interactivetext', this.handleEvent.bind(this));
        console.log('MessageDisplay disconnected');
    }

    static get observedAttributes() {
        console.log('Observed attributes:', ['content-map']);
        return ['content-map'];
    }

    attributeChangedCallback(name, oldValue, newValue) {
        if (name === 'content-map') {
            this.updateContentMap();
            console.log('Content map attribute changed:', newValue);
        }
    }

    updateContentMap() {
        try {
            this.contentMap = JSON.parse(this.getAttribute('content-map')) || {};
            console.log('Content map updated:', this.contentMap);
        } catch (error) {
            console.error('Failed to parse content-map attribute:', error);
            this.contentMap = {};
        }
    }

    handleEvent(event) {
        const id = event.detail;
        console.log('Received interactivetext event with ID:', id);
        const content = this.contentMap[id] || [{ type: 'text', header: { text: "No text", size: 2 }, text: 'No content for this highlight' }];
        console.log('Content for ID:', content);
        this.renderContent(content);
    }

    renderContent(content) {
        const container = this.shadowRoot.querySelector('#content');
        container.innerHTML = ''; // Clear previous content

        const elements = buildContent(content, {});
        console.log('Elements:', elements);
        elements.forEach(element => container.appendChild(element));

        console.log('Updated content:', content);
    }

    render() {
        const style = `
            <style>
                #content {
                    font-size: 16px;
                    color: blue;
                }
            </style>
        `;

        const content = `
            <div id="content">Click a highlight to see the content</div>
        `;

        this.shadowRoot.innerHTML = `${style}${content}`;
    }
}

customElements.define('message-display', MessageDisplay);
    </script>


</body>
</html>